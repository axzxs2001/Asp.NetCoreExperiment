using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Data;

namespace ReflectionGenerator
{

    [Generator]
    public class ReflectionGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {     

            foreach (var partialType in GetPartialTypeDeclarations(context))
            {
                string namespaceName = null;
                SyntaxNode current = partialType;
                while (current != null)
                {
                    if (current is NamespaceDeclarationSyntax namespaceDeclaration)
                    {
                        namespaceName = namespaceDeclaration.Name.ToString();
                        break;
                    }
                    current = current.Parent;
                }
                AddSourse(context, namespaceName, partialType.Identifier.Text);
            }

        }
        void AddSourse(GeneratorExecutionContext context, string nsName, string typeName)
        {
            // Build up the source code
            string source = $@"
// <auto-generated/>
using System;

{(string.IsNullOrWhiteSpace(nsName) ? "" : @$"namespace {nsName}
{{")}
   public partial class {typeName}
   {{
      public override int GetHashCode()
      {{
         typeof({typeName}).GetMembers();
         return base.GetHashCode();
      }}
   }}
{(string.IsNullOrWhiteSpace(nsName) ? "" : @$"}}")}
";
            File.AppendAllText(@"C:\MyFile\temp\error.txt", source + "\r\n");
            context.AddSource($"{typeName}.g.cs", source);
        }

        IEnumerable<TypeDeclarationSyntax> GetPartialTypeDeclarations(GeneratorExecutionContext context)
        {
            var partialTypeDeclarations = new List<TypeDeclarationSyntax>();

            foreach (var tree in context.Compilation.SyntaxTrees)
            {
                var root = tree.GetRoot(context.CancellationToken);
                var typeDecls = root.DescendantNodes().OfType<TypeDeclarationSyntax>();

                foreach (var decl in typeDecls)
                {
                    if (decl.Modifiers.Any(SyntaxKind.PartialKeyword))
                    {
                        partialTypeDeclarations.Add(decl);
                    }
                }
            }
            return partialTypeDeclarations;
        }

        IEnumerable<string> GetAllTypeFullNames(Compilation compilation)
        {
            List<string> fullNames = new List<string>();

            foreach (var tree in compilation.SyntaxTrees)
            {
                var semanticModel = compilation.GetSemanticModel(tree);
                var typeDeclarations = tree.GetRoot().DescendantNodes().OfType<TypeDeclarationSyntax>();

                foreach (var typeDecl in typeDeclarations)
                {
                    var symbol = semanticModel.GetDeclaredSymbol(typeDecl);
                    if (symbol != null)
                    {
                        fullNames.Add(GetFullMetadataName(symbol));
                    }
                }
            }
            return fullNames;
            string GetFullMetadataName(ISymbol s)
            {
                if (s == null || IsRootNamespace(s))
                {
                    return string.Empty;
                }

                var sb = new System.Text.StringBuilder(s.MetadataName);
                var last = s;

                s = s.ContainingSymbol;

                while (!IsRootNamespace(s))
                {
                    if (s is ITypeSymbol && last is ITypeSymbol)
                    {
                        sb.Insert(0, '+');
                    }
                    else
                    {
                        sb.Insert(0, '.');
                    }

                    sb.Insert(0, s.MetadataName);
                    last = s;
                    s = s.ContainingSymbol;
                }

                return sb.ToString();
            }
            bool IsRootNamespace(ISymbol symbol)
            {
                return symbol is INamespaceSymbol n && n.IsGlobalNamespace;
            }
        }

        public void Initialize(GeneratorInitializationContext context)
        {

        }
    }
}
